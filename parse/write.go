package parse

import (
	"fmt"
	"sort"
	"strings"

	log "github.com/Sirupsen/logrus"
)

// WriteStructBody writes the body of a Go type as a Flow type
func (p *Parse) WriteStructBody(s field, level int) {
	var name, typ string
	if s.tags.flow.name != "" {
		name = s.tags.flow.name
	} else if s.tags.json == "" {
		// BUG: This is a patch to get it working. Not sure why this isn't being parsed earlier.
		name = getTag("json", s.tags.original)
	} else {
		name = s.tags.json
	}
	if s.tags.flow.typ != "" {
		typ = s.tags.flow.typ
	} else {
		typ = s.typ
	}

	switch s.typ {
	case "embedded":
		if v, ok := p.mappings[s.tags.flow.name]; ok {
			for _, x := range v {
				if x.tags.flow.name != "" {
					name = x.tags.flow.name
				} else {
					name = getTag("json", x.tags.original)
				}
				if x.typ == "embedded" {
					p.WriteStructBody(x, 0)
					continue
				}
				if x.tags.flow.typ != "" {
					typ = x.tags.flow.typ
				} else {
					typ = x.typ
				}

				p.writeLine(name, typ, x.comment, 0)
			}
		}
	case "struct":
		// Indent the struct key
		for i := 0; i < level; i++ {
			p.Write("\t")
		}
		p.Write(fmt.Sprintf("\t%s: object {\n", name))
		for i := range s.children {
			p.WriteStructBody(s.children[i], level+1)
		}
		for i := level; i > 0; i-- {
			// Indent the ending struct braces
			for j := level; j > 0; j-- {
				p.Write("\t")
			}
		}
		p.Write("\t},\n")
	default:
		p.writeLine(name, typ, s.comment, level)
	}
}

// WriteLine writes one line of a struct body
func (p *Parse) writeLine(name, t, comment string, level int) {
	for i := 0; i < level; i++ {
		// Indent each line the amount of levels it is deep
		p.Write("\t")
	}
	if comment != "" {
		p.Write(fmt.Sprintf("\t%s: %s,\t// %s", name, t, comment))
	} else {
		p.Write(fmt.Sprintf("\t%s: %s,\n", name, t))
	}
}

// Write fails the script if any error.
func (p *Parse) Write(line string) {
	if _, err := p.outfile.Write([]byte(line)); err != nil {
		log.WithError(err).Fatalln("error writing")
	}
}

// WriteDocument writes most of the types to the p.Writer. Should change this to be *ALL* of it, later.
func (p *Parse) WriteDocument() {
	p.Write("//@flow\n\n// DO NOT EDIT -- automatically generated by goflow\n\n")
	removeUnexported(p.mappings)
	for k, v := range p.mappings {
		updateTags(v)
		updateTypes(k, v)
	}

	for k := range p.baseMappings {
		p.baseMappings[k] = field{
			typ:     updateType(p.baseMappings[k].typ),
			name:    p.baseMappings[k].name,
			comment: p.baseMappings[k].comment,
			tags:    p.baseMappings[k].tags,
		}
	}

	// Sort the base types alphabetically
	sortedBase := []string{}
	for k := range p.baseMappings {
		sortedBase = append(sortedBase, k)
	}
	sort.Strings(sortedBase)

	// Sort the structs alphabetically
	sortedStructs := []string{}
	for k := range p.mappings {
		sortedStructs = append(sortedStructs, k)
	}
	sort.Strings(sortedStructs)

	for _, v := range sortedBase {
		if c, ok := p.comments[v]; ok {
			if strings.Contains(c, "// flowignore") {
				continue
			}
			comment := strings.Replace(c, "\n", "\n// ", -1)
			comment = strings.TrimSuffix(comment, `// `)
			p.Write(fmt.Sprintf("// %s", comment))
		}
		p.Write(fmt.Sprintf("export type %s = %s\n\n", p.baseMappings[v].name, p.baseMappings[v].typ))
	}

	for _, v := range sortedStructs {
		if len(p.mappings[v]) == 0 {
			continue
		}

		// open and close are the brackets for containing types
		b := brackets{"{", "}"}
		if c, ok := p.comments[v]; ok {

			// Ignore flowignore comments if @flowignore
			if strings.Contains(c, "\n@flowignore\n") {
				continue
			}

			// Set strict if @strict
			if strings.Contains(c, "\n@strict\n") {
				b = brackets{"{|", "|}"}
			}

			comment := strings.Replace(c, "\n", "\n// ", -1)
			comment = strings.TrimSuffix(comment, `// `)
			p.Write(fmt.Sprintf("// %s", comment))
		}

		p.Write(fmt.Sprintf("export type %s = %s\n", v, b.open))

		for _, s := range p.mappings[v] {
			p.WriteStructBody(s, 0)
		}

		p.Write(fmt.Sprintf("%s\n\n", b.close))

	}
}

// brackets are the opening and closing brackets for a type/struct
type brackets struct {
	open, close string
}
